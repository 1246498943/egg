# 实体层支持

设计目的是为了体现一个基于逻辑概念的对象，这个对象叫做entity。

比如一只狗一只猫。他们是逻辑上的概念和一些属性的合集。并不包含3d模型或者2d图片。

entity这个概念管理自己的如何表达，这是个反向的MVC设计。也就是m自己决定v。而不是v呈现m。

为什么呢，因为v的表达形式很少，也就是3d2d之类的，或者完全不表达（网络同步）。但是m的表达太随意，无法用v来限制。比如一个entity可能表达的是一个node，也可能是多个node，或者node的一部分。我们无法让v支持这么大自由度的m。

## 场景管理

所以我们让entity产生的时候自己决定场景表达。为了应对不同的表达形式，比如3d2d场景图。我们简化了这个过程，entity所能管理的数据只有两种，纯属性，SceneNode。我们将所有的场景图，2d3d或者不同的引擎的node都托管给了SceneNode。这个设计是让问题移动到场景层来解决。

在实体层我们单纯的关心数据和节点关系即可。其他问题完全抛给场景层处理。

## 组件设计

这里不需要包含行为或者组件。为什么？

首先entity是通过继承来解决问题的。所有On开头的接口都是消息输入。所以直接处理就行了。然后我们不可能通过增加一个组件来改变entity的行为。这样会让数据同步变得非常不直观。而且同步又要去管理组件的生存周期。过于复杂。

完全通过继承来使用Entity系统。



在unreal里组件更像是子Entity。所以让Entity是有价值的。比如一个声音播放Entity，就可以添加给另一个Entity。或者一个机械模型包含了很多仪表对象。机械设备本身是一个entity，仪表是一个子entity。

所以entity初始化分几个途径：独立new，从sn建立，从父entity建立。



## 主要设计

Level 实体容器

Entity 实体基础接口

EntityFactory<T>  抽象工程模板

EntityRegister  全局注册器



## Level

作为entity的容器，提供对entity操作的全部接口。我们取消了 EntityManager 的设计。EntityRegister  仅仅提供工厂注册功能，而不负责生命周期的管理。全部管理由Level完成。

Level托管一个SceneNode。来自外部建立。



## Entity

父子关系支持。

提供抽象接口。完成不同消息和状态的管理。

提供反射属性支持。支持默认值，支持基础的数据结构。比如list table等。

提供Object支持。直接继承自Object。本身也是一个反射对象。他的属性自然也是反射对象。



## EntityFactory

全局单例。维护产品生命周期的职责是Level负责的。所以他全局没有任何关系。

